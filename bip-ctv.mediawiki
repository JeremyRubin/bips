<pre>
  BIP: bip-ctv
  Title: CHECKTEMPLATEVERIFY
  Author: Jeremy Rubin <j@rubin.io>
  Status: Draft
  Type: Standards Track
  Created:
  License: BSD-3-Clause
</pre>

==Abstract==

This BIP proposes a new opcode, OP_CHECKTEMPLATEVERIFY, to be activated
as a change to the semantics of OP_NOP4.

The new opcode has applications for transaction congestion control and payment
channel instantiation, among others, which are described in the Motivation
section of this BIP.

==Summary==

OP_CHECKTEMPLATEVERIFY uses opcode OP_NOP4 (0xb3) as a soft fork upgrade.

When the following precondtions are met:

* The preceding operation was a data push (not across the scriptSig/scriptPubKey barrier)
* The element on the stack is 32 bytes long

OP_CHECKTEMPLATEVERIFY verifies the following conditions:

* The SHA256 TaggedHash("StandardTemplateHash") of the serialized version, locktime, outputs hash, sequences hash, number of inputs, and serialized ScriptSig is equal to the element on the stack.


If the preconditions are not met, it is treated as a NOP to permit future extensions.

The recommended standardness rules additionally:

* Reject non-32 byte or empty stack conditions as SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS.
* Reject 32 byte arguments on the stack (whether or not it came from a preceding push) if the value is not equal to the StandardTemplateHash.

==Motivation==

Covenants are restrictions on how a coin may be spent beyond key ownership. Covenants can be useful
to construct smart contracts. As covenants are complex to implement and risk of introducing
fungibility discriminants they have not been seriously considered for inclusion in Bitcoin.

This BIP introduces a simple covenant called a *template* which enables a limited set of highly
valuable use cases without significant risk.

A few examples are described below, which should be the subject of future non-consensus
standardization efforts.

===Congestion Controlled Transactions===

When there is a high demand for blockspace it becomes very expensive to make transactions. A large
volume payment processor may aggregate all their payments into a single O(1) transaction commitment
for purposes of confirmation using CHECKTEMPLATEVERIFY. Then, some time later, the payments can
be expanded out of that UTXO when the demand for blockspace is decreased. These payments can be
structured in a tree-like fashion to reduce individual costs of redemption.


The below chart showcases the structure of these transactions in comparison to
normal transactions and batched transactions.

<img src="ctv/states.svg" align="middle"></img>

A simulation is shown below of what impact this could have on mempool backlog
given 5% network adoption, and 50% network adoption. The code for the simulation
is provided in this BIP's subdirectory.

<img src="ctv/five.png" align="middle"></img>
<img src="ctv/fifty.png" align="middle"></img>

===Payment Channels===
There are numerous payment channel related uses.

====Channel Factories====

Using CHECKTEMPLATEVERIFY for Channel Factories is similar to the use for Congestion Control,
except the leaf node transactions are channels instead of plain payments. The channel can be between
the sender and recipient or a target of recipient's choice. Using an CHECKTEMPLATEVERIFY, the
recipient may give the sender an address which makes a tree of channels unbeknownst to them.
These channels are time insensitive for setup, as all punishments are relative timelocked to the
penultimate transaction node.
Thus, coins sent using a congestion controlled transaction can still enjoy instant liquidity.

====Non-Interactive Channels====
When opening a traditional payment channel, both parties to the channel must participate. This is
because the channel uses pre-signed multi-sig transactions to ensure that a channel can always be
exited by either party, before entering.
With CHECKTEMPLATEVERIFY, itâ€™s possible for a single party to construct a channel which either
party can exit from without requiring signatures from both parties.
These payment channels can operate in one direction, paying to the channel "listener" without need
for their private key to be online.
<img src="ctv/nic.svg" align="middle"></img>

====Increased Channel Routes====
In the Lightning Network protocol, Hashed Time Locked Contracts (HTLCS) are used in the construction
of channels. A new HTLC is required per route that the channel is serving in.
In BOLT #2, this maximum number of HTLCs in a channel is hard limited to 483 as the maximum safe
size to prevent the transaction from being too large to be valid. In common software implementations
such as LND, this limit is set much lower to 12 HTLCS. This is because accepting a larger number of
HTLCS makes it more difficult for transactions to confirm during congested periods as they must pay
hire fees.
Therefore, similarly to how congestion control is handled for normal transaction, lightning channel
updates can be done across an CHECKTEMPLATEVERIFY tree, allowing nodes to safely use many more
HTLCS.
Because each HTLC can have its own relative time lock in the tree, this also improves the latency
sensitivity of the lightning protocol on contested channel close.


===Wallet Vaults===

When greater security is required for cold storage solutions, there can be
default script paths that move funds from one target to another target.
For example, a cold wallet can be set up where one customer support desk can,
without further authorization, move a portion of the funds (using multiple
pre-set amounts) into a lukewarm wallet operated by an isolated support desk.
The support desk can then issue some funds to a hot wallet, and send the
remainder back to cold storage with a similar withdrawal mechanism in place.
This is all possible without CHECKTEMPLATEVERIFY, but CHECKTEMPLATEVERIFY
eliminates the need for coordination and online signers, as well as reducing the
ability for a support desk to improperly move funds.
Furthermore, all such designs can be combined with relative time locks to give
time for compliance and risk desks to intervene.

<img src="ctv/vaults.svg" align="middle"></img>

===CoinJoin===

CHECKTEMPLATEVERIFY makes it much easier to set up trustless CoinJoins than previously because
participants agree on a single output which pays all participants, which will be lower fee than
before.  Further Each participant doesn't need to know the totality of the outputs committed to by
that output, they only have to verify their own sub-tree will pay them.

==Detailed Specification==
The below code is the main logic for verifying CHECKTEMPLATEVERIFY, and is the canonical
specification for the semantics of OP_CHECKTEMPLATEVERIFY.
    case OP_CHECKTEMPLATEVERIFY:
    {
        // if flags not enabled; treat as a NOP4
        if (!(flags & SCRIPT_VERIFY_STANDARD_TEMPLATE)) break;
        // N.B., for the following two conditions users of OP_CHECKTEMPLATEVERIFY should
        // be careful to ensure that they are not *relying* on either of these rules to
        // treat OP_CHECKTEMPLATEVERIFY as future soft-forks will use these NOPs for
        // upgrades. As such, we return the SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS when
        // applicable.
        //
        // if the top of the stack isn't a constexpr, ignore and treat as OP_NOP4.
        //
        // Currently only a pushdata or number, not cross scriptSig/scriptPubKey, is
        // constexpr.  This allows future soft-forks to broaden what we consider a
        // "constexpr" to include stack items like the OP_DUP of something which is
        // constexpr, so long as nothing which was formerly constexpr becomes
        // non-constexpr.
        //
        // This also allows an eventual soft-fork to remove the constexpr check
        // altogether, if shown to be safe to pass in the template parameters.
        bool was_nop = stack.empty();
        if (!was_nop) {
            // If the data was not 32 bytes, treat as OP_NOP4:
            //     future upgrade can add semantics for this opcode with different length args
            switch (stack.back().size()) {
            case 32:
            {
                // only constexpr data is not treated as NOP
                was_nop |= !top_of_stack_is_constexpr;
                // don't check further if we were a NOP for consensus, and we don't want to check
                // for standardness rules
                if (was_nop && !(flags & SCRIPT_VERIFY_STRICT_STANDARD_TEMPLATE)) 
                    break;
                // Check the Template Hash computed from the transaction matches the literal value
                if (!checker.CheckStandardTemplateHash(stack.back()))
                    return set_error(serror, SCRIPT_ERR_TEMPLATE_MISMATCH);
                break; //! break to end of switch
            }
            default:
            {
                was_nop |= true;
                break; //! break to end of switch
            }
            } //! end switch
        }
        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) && was_nop)
            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);
        break;
    }

The hash is computed as follows:

    CHashWriter TaggedHash(const std::string& tag) {
        CHashWriter writer(SER_GETHASH, 0);
        uint256 taghash;
        CSHA256().Write((unsigned char*)tag.data(), tag.size()).Finalize(taghash.begin());
        writer << taghash << taghash;
        return writer;
    }
    uint256 GetSequenceSHA256(const CTransaction& tx) {
        CHashWriter ss(SER_GETHASH, 0);
        for (const auto& in : tx.vin) ss << in.nSequence;
        return ss.GetSHA256();
    }
    uint256 GetOutputsSHA256(const CTransaction& tx) {
        CHashWriter ss(SER_GETHASH, 0);
        for (const auto& out : tx.vout) ss << out;
        return ss.GetSHA256();
    }
    uint256 GetStandardTemplateHash(const CTransaction& tx) {
        auto h =  TaggedHash("StandardTemplateHash")
            << tx.nVersion << tx.nLockTime
            << GetOutputsSHA256(tx) << GetSequenceSHA256(tx)
            << uint64_t(tx.vin.size());
        for (const auto& in : tx.vin) h << in.scriptSig;
        return h.GetSHA256();
    }


A PayToBasicStandardTemplate output matches the following template:

    bool CScript::IsPayToBasicStandardTemplate() const
    {
     // Extra-fast test for pay-to-basic-standard-template CScripts:
     return (this->size() == 34 &&
             (*this)[0] == 0x20 &&
             (*this)[33] == OP_CHECKTEMPLATEVERIFY);
    }

==Deployment==

Deployment should be done via BIP 9 VersionBits.

The start time and bit in the implementation are currently set to bit 5 and
March 1st, 2020, but this is subject to change while the BIP is a draft.

For the avoidance of unclarity, the parameters are:

    consensus.vDeployments[Consensus::DEPLOYMENT_CHECKTEMPLATEVERIFY].bit = 5;
    consensus.vDeployments[Consensus::DEPLOYMENT_CHECKTEMPLATEVERIFY].nStartTime = 1583020800; // March 1, 2020
    consensus.vDeployments[Consensus::DEPLOYMENT_CHECKTEMPLATEVERIFY].nTimeout = 1614556800; //  March 1, 2021

In order to facilitate using CHECKTEMPLATEVERIFY, the common case of a PayToBasicStandardTemplate
with no scriptSig data shall be made standard to permit relaying. Future template types may be
standardized later as policy changes.

==Implementations==

An example implementation and tests are available here:
https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify.


==Design Notes==

The goal of CHECKTEMPLATEVERIFY is to be minimal impact on the existing codebase -- in the
future, as we become aware of more complex but shown to be safe use cases new template types can be 


Below we'll discuss the rules one-by-one:


====Is a NOP if the preceding operation was not a data push of 32 bytes====

CHECKTEMPLATEVERIFY acts as a NOP if the element on the stack wasn't 32 bytes to allow for new
template upgrades in the future.

CHECKTEMPLATEVERIFY is a NOP if the element on the stack wasn't an immediately pushed value,
because were CHECKTEMPLATEVERIFY to use the data from the stack indiscriminately it would be
possible to compute in script what data is committed to or pass in via the witness. By forcing the
hash to be directly from a preceding push in order to not be a NOP, we ensure that the exact
template is known at the time of creating the transaction output.

Minimalism is partially why CHECKTEMPLATEVERIFY uses a PushData32 (0x20) rather than a
literal/immediate value by using a new script version. It is messy to upgrade the parser to treat
old opcodes as multi-byte opcodes. This can be done, perhaps within the context of new script
versions like Tapscript, depending on community feedback and preference. The other reason is that
this provides a clean upgrade path for lightening the restriction in the future.


A script programmer is still able to conditionalize which hash is checked, e.g., <code>OP_IF
<H1> OP_CHECKTEMPLATEVERIFY OP_ELSE <H2> OP_CHECKTEMPLATEVERIFY OP_ENDIF</code>. If the conditions
are nested (e.g. <code> if (a) {if (b){}else{} } else {if (c){} else{}}</code>), with the property
that a parent branch condition being true implies there is a valid child branch, then it is possible
to use CHECKTEMPLATEVERIFY to merkelize the condtions into a tree-like program at the transaction
level to be able to express a O(N) program in log(N) space.


In the future, should Taproot become available, a user is more likely to compile code with multiple
CHECKTEMPLATEVERIFY operations into separate Tapscript branches.

====The SHA256 TaggedHash("StandardTemplateHash") of the serialized version, locktime, outputs hash, sequences hash, number of inputs, and serialized ScriptSig matches the top of the stack==== 

The set of data committed to is the set of data which can impact the TXID of the transaction, other
than the inputs. This ensures that for a given known input, the TXIDs can also be known ahead of
time as long as the inputs are SegWit.  Otherwise, CHECKTEMPLATEVERIFY would not be usable for
Channel Factory type constructions as the redemption TXID could be malleated and pre-signed
transactions invalidated.

It is not a concern that exposing this hash on the stack might allow parsing of
the data hashed, because they are already known exactly at the time of script
construction so could just be compiled in.

=====Committing to the outputs hash=====

This ensures that spending the UTXO is guaranteed to create the exact outputs
requested.

We commit to the hash rather than the values themselves as this is already
precomputed for each transaction to optimize SIGHASH_ALL signatures.

=====Committing to the Sequences Hash=====

If we don't commit to the sequences, then the TXID can be malleated. This also allows us to enforce
a relative sequence lock without an OP_CSV. It is insufficient to just pair CHECKTEMPLATEVERIFY
with OP_CSV because OP_CSV enforces a minimum nSequence value, not a literal value.

We commit to the hash rather than the values themselves as this is already
precomputed for each transaction to optimize SIGHASH_ALL signatures.


=====Committing to the ScriptSig=====

The scriptsig in a segwit transaction must be exactly empty, unless it is a P2SH
segwit transaction in which case it must be only the exact redeemscript. P2SH is incompatible
(unless the P2SH hash is broken) with CHECKTEMPLATEVERIFY because the template hash must commit
to the  ScriptSig, which must contain the redeemscript, which is a hash cycle.

To prevent succeptibility to malleability when not using a segwit input, we also
commit to the scriptsig. This makes it possible to use a 2 input CHECKTEMPLATEVERIFY
with a legacy pre-signed spend, as long as the exact scriptsig for the legacy
output is committed.

=====Committing to the version and locktime=====

Were these values not committed, it would be possible to delay the spending of
an output arbitrarily as well as possible to change the TXID.

Committing these values, rather than restricting them to specific values, is
more flexible as it permits users of CHECKTEMPLATEVERIFY the set the version and
locktime as they please.

=====Committing to the number of inputs=====

If we allow more than one input to be spent in the transaction then it would be
possible for two outputs to request payment to the same set of outputs,
resulting in half the intended payments being discarded, the "half-spend" problem.

Furthermore, the restriction on which inputs can be co-spent is critical for
payments-channel constructs where a stable TXID is a requirement (updates would
need to be signed on all combinations of inputs).

However, there are legitimate use cases for allowing multiple inputs. For
example:

Script paths: 

    Path A: <+24 hours> OP_CHECKSEQUENCEVERIFY OP_CHECKTEMPLATEVERIFY <Pay Alice 1 Bitcoin (1 input) nLockTime for +24 hours>
    Path B: OP_CHECKTEMPLATEVERIFY <Pay Bob 2 Bitcoin (2 inputs)>

In this case, there are 24 hours for the output to, with the addition of a
second output, pay Bob 2 BTC. If 24 hours lapses, then Alice may redeem her 1
BTC from the contract. Both input UTXOs may have the exact same Path B, or only one.

The issue with these constructs is that there are N! orders that the inputs can
be ordered in and it's not generally possible to restrict the ordering.

CHECKTEMPLATEVERIFY allows for users to guarantee the exact number of inputs being
spent. In general, using CHECKTEMPLATEVERIFY with more than one input is difficult
and exposes subtle issues, so multiple inputs should not be used except in
specific applications.

===Design Tradeoffs and Risks===
Covenants have historically been controversial given their potential for fungibility risks -- coins
could be minted which have a permanent restriction on how they may or may not be spent or required
to propagate metadata.

In the CHECKTEMPLATEVERIFY approach, the covenants are severely restricted to simple templates. The
structure of CHECKTEMPLATEVERIFY template is such that the outputs must be known exactly at the
time of construction. Based on a destructuring argument, it is only possible to create templates
which expand in a finite number of steps. Thus templated transactions are in theory as safe as
transactions which create all the inputs directly in this regard..

Furthermore, templates are restricted to be spendable as a known number of inputs only, preventing
unintentional introduction of the 'half spend' problem. 


Templates, as restricted as they are, bear some risks.  

====Permanently Unspendable Outputs====
The preimage argument passed to CHECKTEMPLATEVERIFY may be unknown or otherwise unsatisfiable.
However, requiring knowledge that an address is spendable from is incompatible with sender's ability
to spend to any address (especially, OP_RETURN). If a sender needs to know the template can be spent
from before sending, they may request a signature of an provably non-transaction challenge string
from the leafs of the CHECKTEMPLATEVERIFY tree.

====Forwarding Addresses====
Key-reuse with CHECKTEMPLATEVERIFY may be used as a form of "forwarding address contract".
A forwarding address is an address which can automatically execute in a predefined way.
For example, a exchange's hot wallet might use an address which can automatically be moved to a cold
storage address after a relative timeout.
The issue is that reusing addresses in this way can lead to loss of funds. 
Suppose one creates an template address which forwards 1 BTC to cold storage. 
Creating an output to this address with less than 1 BTC will be frozen permanently.
Paying more than 1 BTC will lead to the funds in excess of 1BTC to be paid as a large miner fee.
CHECKTEMPLATEVERIFY could commit to the exact amount of bitcoin provided by the inputs/amount of fee
paid, but as this is a user error and not a malleability issue this is not done.
Future soft-forks could introduce opcodes which allow conditionalizing which template or script
branches may be used based on inspecting the amount of funds available in a transaction

As a general best practice, it is incumbent on Bitcoin users to not reuse any address unless you are
certain that the address is acceptable for the payment attempted. This limitation and risk is not
unique to CHECKTEMPLATEVERIFY. For example, atomic swap scripts are single use once the hash is
revealed. Future Taproot scripts may contain many logical branches that would be unsafe for being
spent to multiple times (e.g., a Hash Time Lock branch should be instantiated with unique hashes
each time it is used). Keys which have signed a SIGHASH_ANYPREVOUT transaction can similarly become
reuse-unsafe.


====NOP-Default and Standardness Rules====

If the argument is not an exact match for a 32-byte previously pushed value, CHECKTEMPLATEVERIFY
treats it as a NOP. Many OP_NOP upgrades prefer to fail in such circumstances. In particular, for
CHECKTEMPLATEVERIFY, making an invalid argument a NOP permits future soft-forks to upgrade the
semantics or loosed restrictions around the value being previously pushed only.

The standardness rules may lead an unscrupulous script developer to accidentally rely on the
stricter standardness rules to be enforced during consensus. Should that developer submit a
transaction directly to the network relying on standardness rejection, an standardness-invalid but
consensus-valid transaction may be caused, leading to a potential loss of funds.

The standardness flags are designed to make it easy for a future soft-fork to lift the previously
pushed data only requirement.

Alternatively, standardness rules could accept 32 byte arguments on the stack when the hash on the
stack is equal to the StandardTemplateHash, whether or not it came from a preceding push, even if
consensus rules won't enforce it.  This permits a future upgrade to broaden the type of template
hashes verified in consensus easily and maintain compatibility with prior standardness rules. It
also simplifies the rules for script interpreters that just want to verify standardness rules to not
need to track the source of the most recent item on the stack. However, the risk of misuse means
this should not be the default approach taken, and such scripts should be rejected. As a compromise,
if the non-mandatory flag SCRIPT_VERIFY_STRICT_STANDARD_TEMPLATE is set and the argument is any
32-byte value, it will be rejected with a SCRIPT_ERR_TEMPLATE_MISMATCH (if it does mismatch)
rather than a SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS.

====Feature Redundancy====
CHECKTEMPLATEVERIFY templates are substantially less risky than other covenant systems. If
implemented, other covenant systems could make the CHECKTEMPLATEVERIFY's functionality redundant.
However, given CHECKTEMPLATEVERIFY's simple semantics and low on chain cost it's likely that it
would continue to be favored even if redundant with other capabilities.

More powerful covenants like those proposed by MES16, would also bring some benefits in terms of
improving the ability to adjust for things like fees rather than relying on child-pays-for-parent or
other mechanisms. However, these features come at substantially increased complexity and room for
unintended behavior.

Alternatively, SIGHASH_ANYPREVOUTANYSCRIPT based covenant designs can implement
something similar to templates, via a scriptPubKey like:


    <sig of desired TX with PK and fixed nonce R || SIGHASH_ANYPREVOUTANYSCRIPT> <PK with public SK> OP_CHECKSIG

SIGHASH_ANYPREVOUTANYSCRIPT bears additional technical and implementation risks that may preclude
its viability for inclusion in Bitcoin, but the capabilities above are similar to what
CHECKTEMPLATEVERIFY offers.  However, CHECKTEMPLATEVERIFY has benefits in terms of verification
speed, as it requires only hash computation rather than signature operations. This can be
significant when constructing large payment trees or programmatic compilations. CHECKTEMPLATEVERIFY
also has a feature-wise benefit in that it provides a robust pathway for future template upgrades.

CHECKSIGFROMSTACK along with OP_CAT may also be used to emulate CHECKTEMPLATEVERIFY.  However such
constructions are more complicated to use than CHECKTEMPLATEVERIFY, and encumbers additional
verification overhead absent from CHECKTEMPLATEVERIFY. These types of covenants also bear similar
potential recursion issues to OP_COV which make it unlikely for inclusion in Bitcoin.


Given the simplicity of this approach to implement and analyze, and the benefits realizable by user
applications, CHECKTEMPLATEVERIFY's template based approach is proposed in lieu of more complete
covenants system.



== References ==
*[[https://utxos.org|utxos.org informational site]]
*[[https://youtu.be/YxsjdIl0034?t=2451|Scaling Bitcoin Presentation]]
*[[https://bitcoinops.org/en/newsletters/2019/05/29/|Optech Newsletter Covering OP_CHECKOUTPUTSHASHVERIFY]]
*[[https://cyber.stanford.edu/sites/g/files/sbiybj9936/f/jeremyrubin.pdf|Structuring Multi Transaction Contracts in Bitcoin]]
*[[https://github.com/jeremyrubin/lazuli]|Lazuli Notes (ECDSA based N-of-N Signatures for Certified Post-Dated UTXOs)]]
*[[https://fc16.ifca.ai/bitcoin/papers/MES16.pdf|Bitcoin Covenants]]
*[[https://bitcointalk.org/index.php?topic=278122.0|CoinCovenants using SCIP signatures, an amusingly bad idea.]]
*[[https://fc17.ifca.ai/bitcoin/papers/bitcoin17-final28.pdf|Enhancing Bitcoin Transactions with Covenants]]


===Note on Similar Alternatives===
An earlier version of CHECKTEMPLATEVERIFY, CHECKOUTPUTSHASHVERIFY, is withdrawn
in favor of CHECKTEMPLATEVERIFY. CHECKOUTPUTSHASHVERIFY did not commit to the
version or lock time and was thus insecure.

CHECKTEMPLATEVERIFY could also be implemented as an extension to Taproot, and was
proposed this way earlier. However, given that CHECKTEMPLATEVERIFY has no dependency
on Taproot, it is preferable to deploy it independently.

CHECKTEMPLATEVERIFY has also been previously referred to as OP_SECURETHEBAG, which is mentioned here
to aid in searching and referencing discussion on this BIP.

==Copyright==
This document is licensed under the 3-clause BSD license.

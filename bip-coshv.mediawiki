<pre>
  BIP: bip-coshv
  Title: OP_CHECKOUTPUTSHASHVERIFY
  Author: Jeremy Rubin <j@rubin.io>
  Status: Draft
  Type: Standards Track
  Created:
  License: BSD-3-Clause
</pre>

==Abstract==

This BIP proposes a new opcode, OP_CHECKOUTPUTSHASHVERIFY, to be activated
for Tapscript version 0.

==Summary==

CHECKOUTPUTSHASHVERIFY uses opcode OP_RESERVED1 (0x89) during Tapscript execution.

CHECKOUTPUTSHASHVERIFY verifies the following conditions:

* The following script is a minimal data push of 32 bytes
* There is only one input spent in this transaction
* The SHA256 double-hash of the serialized outputs matches the value provided

If the operations following CHECKOUTPUTSHASHVERIFY are not a 32-byte data push,
it is ignored. Otherwise, if the conditions are not met, execution fails.

==Motivation==

Covenants -- or restrictions on how a coin may be spent beyond key ownership --
are a highly powerful construct for structuring smart contracts. However, given
their complexity and potential for introducing fungibility risks they have not
been seriously considered for inclusion in Bitcoin thus far.

This BIP aims to introduce a minimum viable covenant which enables a limited set
of practical features. For example:

===Congestion Controlled Transactions===

When there is a large demand for blockspace it can become very expensive to make
payments. By using CHECKOUTPUTSHASHVERIFY, a large volume payment processor may
aggregate all their payments into a single O(1) transaction for purposes of
confirmation. Then, some time later, the payments can be expanded out of that
UTXO when the demand for blockspace is decreased.

Without CHECKOUTPUTSHASHVERIFY, this is still possible to do with Schnorr
signatures (even with ECDSA given multiparty schemes). However, it is not
possible to do non-interactively, which fundamentally limits the viability of
the approach.

To structure a congestion control transaction as user has multiple options --
it can simply be a single step from 1 output to N, or, a user can commit to a
tree of outputs using CHECKOUTPUTSHASHVERIFY which permits them to confirm as
many payments as they like. Furthermore, the Taproot can commit to variable size
expansions -- say, one node which expands by 2, by 4, by 8, etc. This allows a
trade off between transaction overhead and immediately available block space.
The Merkle tree lookup in that case is O(log(log(N))) extra overhead, but the
tree can be Huffman encoded to make it E[O(1)] depending on block demand. Each
node of the tree can also attempt to 'opt in' to preferring a Taproot signature
based spend, but if participants are offline or malicious the expansion can
proceed to smaller groups.

The overall overhead of this approach (without optimizations) is from the
perspective of each user O(log(N)) transactions with an expectation of just 1
additional transaction, and 2N from the perspective of the network. However,
given the lack of signatures required for such transactions, the actual overhead
is less.

The below chart showcases the structure of these transactions in comparison to
normal transactions and batched transactions.

<img src="bip-coshv/states.png" align="middle"></img>

A simulation is shown below of what impact this could have on mempool backlog
given 5% network adoption, and 50% network adoption. The code for the simulation
is provided in this BIP's subdirectory.

<img src="bip-coshv/five.png" align="middle"></img>
<img src="bip-coshv/fifty.png" align="middle"></img>

===Channel Factories===

This use case is similar to as above, except instead of payments, the leaf nodes
should be set up as a channel (perhaps between the payer and payee or a target
of payee's choice).

These channels are already time insensitive for setup, as all punishments can be
relative timelocked to the actual instantiation.

This permits instant liquidity on the coins sent using this delayed method.

===Wallet Vaults===

When greater security is required for cold storage solutions, there can be
default Tapscript paths that move funds from one target to another target.

For example, a cold wallet can be set up where one customer support desk can,
without further authroization, move a portion of the funds (using multiple
pre-set amounts) into a lukewarm wallet operated by an isolated support desk.
The support desk can then issue some funds to a hot wallet, and send the
remainder back to cold storage with a similar withdrawal mechanism in place.

This is all possible without CHECKOUTPUTSHASHVERIFY, but CHECKOUTPUTSHASHVERIFY
eliminates the need for coordination and online signers, as well as reducing the
ability for a support desk to improperly move funds.

Furthermore, all such designs can be combined with relative time locks to give
time for compliance and risk desks to intervene.


===CoinJoin===

This sort of approach makes it much easier to set up a trustless CoinJoin.

All participants agree on a single UTXO which commits to its output hash,
participants then can fund the transaction with whatever inputs they like.

Then, the transaction can be confirmed.

If desired, the Tapscript path can be usurped by a signature based spend to
improve fungibility.


==Design==

The goal of CHECKOUTPUTSHASHVERIFY is to be minimal impact on the existing
codebase -- in the future, as we become aware of more complex but shown to be
safe use cases new covenant types might be enabled.

Critically, because this is a Tapscript, it is intended that participants may
collaborate to replace the Tapscript path with a signature. This lifts the
requirement of the output being spent alone and the exact match of output
hashes, if other dependencies (like channel state) can be updated.

Below we'll discuss the
rules one-by-one:


====The following script is a minimal data push of 32 bytes====

CHECKOUTPUTSHASHVERIFY uses the push after the opcode rather than before the
opcode. Were CHECKOUTPUTSHASHVERIFY to use the data from the stack it would be
possible to construct in script what data is committed to. By using a data
lookahead, we ensure that the outputs are known at the time of spending.

The script programmer is still able to conditionalize which hash it is checked
on, e.g., <code>OP_IF OP_CHECKOUTPUTSHASHVERIFY <outputs 1> OP_ELSE <outputs 2>
OP_ENDIF</code>. However, by keeping the outputs literal hashes we limit the
possibilities.

In any case, a user is more likely to, given Tapscript's API, compile any code
with multiple <code>OP_CHECKOUTPUTSHASHVERIFY</code> operations into separate branches.

====There is only one input spent in this transaction====

If we allow more than one input to be spent in the transaction then it would be
possible for two outputs to request payment to the same set of outputs,
resulting in half the intended payments being discarded. While there are safe
ways to allow multiple inputs, the design is much more complicated and the use
case less clear.

Furthermore, the restriction on which inputs can be co-spent is critical for
payments-channel constructs where a stable TXID is a requirement.

====The SHA256 double-hash of the serialized outputs matches the value provided====

This is a hash which is already computed so it saves us from extra verification
overhead. Thus, <code>OP_CHECKOUTPUTSHASHVERIFY</code> does not impose substantial
additional verification overhead.

It is not a concern that exposing this hash on the stack might allow parsing of
the outputs, because they are already known exactly at the time of script
construction.


==Specification==
The below code is the main logic for verifying <code>OP_CHECKOUTPUTSHASHVERIFY</code>.


    case OP_CHECKOUTPUTSHASHVERIFY:
    {
        // Don't verify before enabled...
        if (flags & SCRIPT_VERIFY_OUTPUTS_HASH) {
            CScript::const_iterator lookahead = pc;
            opcodetype argument;
            // Read ahead one opcode as a lookahead argument
            if (!script.GetOp(lookahead, argument, vchPushValue))
                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
            // If lookahead argument was exactly 32 bytes, check OutputHash
            // This is so that we can later add different semantics for this opcode
            if (vchPushValue.size() == 32) {
                // Argument should be == 0x20 -- will fail later anyways
                if (!CheckMinimalPush(vchPushValue, argument)) {
                    return set_error(serror, SCRIPT_ERR_MINIMALDATA);
                }
                // If multiple inputs allowed, two inputs with the same OutputsHashVerify
                // would pay only half intended amount!
                if (!checker.CheckOnlyOneInput()) {
                    return set_error(serror, SCRIPT_ERR_OUTPUTSHASHVERIFY);
                }
                // Lastly, check that the outputs hash matches the passed value
                if (!checker.CheckOutputsHash(vchPushValue)) {
                    return set_error(serror, SCRIPT_ERR_OUTPUTSHASHVERIFY);
                }
            }
        }
    }
    break;



==Deployment==

The deployment is intended to be done with Tapscript https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki.



==Implementations==

An implementation and tests are available here: https://github.com/JeremyRubin/bitcoin/tree/congestion-control.



==Copyright==
This document is licensed under the 3-clause BSD license.
